同步/异步日志系统
===============
同步/异步日志系统主要涉及了两个模块，一个是日志模块，一个是阻塞队列模块,其中加入阻塞队列模块主要是解决异步写入日志做准备.
> * 自定义阻塞队列
> * 单例模式创建日志
> * 同步日志
> * 异步日志
> * 实现按天、超行分类

Log::write_log 函数是用来写入日志的核心函数，它在不同的日志级别和情况下被调用来记录日志信息。此函数的工作原理如下：

### 函数参数
int level: 日志级别，通常包括 **debug（0）、info（1）、warn（2）、erro（3）** 等。这些级别帮助区分日志信息的重要性。
const char *format, ...: 可变参数，用于格式化日志信息。这类似于 printf 函数，允许用户自定义日志消息的格式。

### 日志写入流程

获取当前时间：
使用 gettimeofday 获取当前时间，并转换为常见的日期和时间格式。

根据日志级别设置前缀：
根据传入的 level 参数，设置相应的日志级别前缀，如 [debug]:、[info]: 等。

格式化日志信息：
使用传入的格式化字符串和参数，格式化日志信息。

日志写入：
根据日志系统是同步还是异步模式，处理日志信息的写入。

在异步模式下，日志信息被加入到一个阻塞队列中，由另一个线程负责从队列中取出日志信息并写入文件。
在同步模式下，日志信息直接写入到日志文件中。

### 何时调用 write_log
当需要记录特定事件或信息时，可以调用 write_log 函数。例如：
记录程序启动和关闭的信息。
记录程序运行中的关键操作、错误、警告或调试信息。
记录用户操作、系统状态变更等重要事件。
开发者可以根据程序中的具体需求和场景，选择合适的日志级别和时机来调用这个函数。例如，处理错误时使用 erro 级别，进行常规操作记录时使用 info 级别，进行问题调试时使用 debug 级别等。这样的灵活性使得日志系统既能提供详细的信息用于调试和分析，又能避免过多的无关信息干扰核心日志内容。

### 调用示例



#include "Log.h"

int main() {
    // 初始化日志系统
    Log::Instance()->init("my_log", 1, 800, 5000, 10);

    // 程序中的各种事件
    try {
        // 程序的其他操作
        Log::Instance()->write_log(1, "Program started");

        // 假设这里发生了一些操作
        // ...

        // 记录一个信息级别的日志
        Log::Instance()->write_log(1, "An important operation was successfully performed");

        // 假设这里出现了一个错误
        throw std::runtime_error("An error occurred");

    } catch (const std::exception& e) {
        // 记录错误级别的日志
        Log::Instance()->write_log(3, "Error occurred: %s", e.what());
    }

    // 程序结束前的日志
    Log::Instance()->write_log(1, "Program ended");

    return 0;
}
